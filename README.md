# Zoo_java
[Ссылка на скринкаст](https://vkvideo.ru/video-235222291_456239017?list=ln-BjbbewYhBdYKmQWW56)

# 1. Описание предметной области
Программа моделирует функционирование зоопарка, включая аспекты управления животными, питанием, уходом, билетами и взаимоотношениями с посетителями. Основные сущности могут включать животных, их типы, уход (включая здоровье и питание), посетителей, работников зоопарка и события, такие как кормежка и шоу с участием животных.

# Реализация принципов SOLID
# 2. Single Responsibility Principle (SRP)
Каждый класс в программе отвечает за одну конкретную задачу. Например, класс Animal отвечает только за свойства и поведение животных (чистота, сытость, здоровье), в то время как класс Zoo управляет логикой взаимоотношений между животными и работниками, например, отслеживает, сколько голодных животных. Это снижает сложность и делает код более читаемым и поддерживаемым.

# 3. Open/Closed Principle (OCP)
Программа проектируется так, чтобы классы были открыты для расширения, но закрыты для модификаций. Например, можно создать новый класс Snake, наследуемый от общего класса Animal, без изменения кода уже существующих животных. Это позволяет добавлять новые виды животных с новой логикой или поведением, не затрагивая существующий код.

# 4. Liskov Substitution Principle (LSP)
При реализации иерархии классов гарантируется, что подклассы могут быть использованы как методы своего суперкласса без нарушения функциональности. Например, все классы животных могут быть использованы в методах, которые работают с типом Animal, независимо от их конкретной реализации. Это обеспечивает возможность замены одного класса другим с минимальными изменениями кода.

# 5. Interface Segregation Principle (ISP)
Интерфейсы разделены по функциональности, чтобы клиенты не были вынуждены реализовывать ненужные методы. Например, интерфейсы для классов работников зоопарка могут включать Stylist для ухода за чистотой животных и Doctor для медицинского ухода. Это позволяет расширять функциональность, не заставляя все классы реализацией множества методов, не относящихся к их роли.

# 6. Dependency Inversion Principle (DIP)
Программа зависима от абстракций, а не от конкретных классов. Например, используется абстрактный класс Animal, который реализуют различные классы животных. Это упрощает тестирование и замену классов, так как изменение одной реализации не требует переписывания других классов. Но, возможно, является не настолько подходящим как на его месте мог бы быть интерфейс.

# 7. Проблемы могут возникнуть в следующих ситуациях:

    Сложные зависимости между классами. При создании новых типов животных или работников, так как они слабо связаны с интерфейсами, может потребоваться модифицировать существующие классы или зависимости.
    Обширные классы. Если класс становится слишком большим или многофункциональным из-за сложной логики, добавление нового функционала потребует значительных изменений.

# 8. Введенные абстракции улучшают качество дизайна за счет:

    Читаемости и высокоуровневой структуры кода. Каждая часть программы легко понимается, когда классы и интерфейсы имеют четкие назначения.
    Упрощения тестирования. Благодаря слабой связанности и четким контрактам между компонентами, юнит-тестирование становится проще и эффективнее.
    Гибкости. Легче добавлять новые функциональные возможности и расширять систему, сохраняя ее стабильность и надежность.
    Модульности. Возможность изменения и доработки отдельных частей без влияния на остальную систему.
